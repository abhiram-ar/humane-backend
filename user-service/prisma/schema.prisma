// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_URI")
}

model User {
  id              String   @id @default(ulid())
  firstName       String
  lastName        String?
  email           String   @unique
  passwordHash    String?
  isEmailVerified Boolean  @default(false)
  isBlocked       Boolean  @default(false)
  isHotUser       Boolean  @default(false)
  avatarKey       String?
  coverPhotoKey   String?
  bio             String   @default("")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @default(now())
  lastLoginTime   DateTime @default(now())
  humaneScore     Int      @default(0)

  FriendShipsAsUser1 FriendShip[] @relation("User1Friendships")
  FriendShipsAsUser2 FriendShip[] @relation("User2Friendships")

  FriendRequestSend    FriendShip[] @relation("FriendRequestSend")
  FriendRequestRecived FriendShip[] @relation("FriendRequestReceived")

  UserBlockedBy BlockedUser[] @relation("UserBlockedBy")
  UsersBlocked  BlockedUser[] @relation("UsersBlocked")

  @@index(fields: [email])
}

model FriendShip {
  id      String @default(ulid())
  user1Id String // should be < user2Id, enforce in DB level and app level
  user2Id String
  user1   User   @relation("User1Friendships", fields: [user1Id], references: [id], onDelete: Cascade)
  user2   User   @relation("User2Friendships", fields: [user2Id], references: [id], onDelete: Cascade)

  requesterId   String //Must be either user1Id or user2Id
  receiverId    String
  RequestedUser User   @relation("FriendRequestSend", fields: [requesterId], references: [id])
  ReceivingUser User   @relation("FriendRequestReceived", fields: [receiverId], references: [id])

  status    FriendShipStatus @default(PENDING)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @default(now())

  @@id([user1Id, user2Id])
  @@index([status])
  @@index([createdAt, id])
}

// why cant we keep this in friendship model?
// 1. null hell: most of the fields will be null -> wastage of storage
// 2. A user can still be blocked if they dont have a friendship, so this will be outside the scope of friendship
model BlockedUser {
  blockerId String
  blockedId String
  createdAt DateTime @default(now())

  blocker User @relation("UserBlockedBy", fields: [blockerId], references: [id])
  blocked User @relation("UsersBlocked", fields: [blockedId], references: [id])

  @@id([blockerId, blockedId])
}

model Admin {
  id           String  @id @default(ulid())
  firstName    String
  lastName     String?
  email        String  @unique
  passwordHash String

  @@index(fields: [email])
}

model OutBox {
  id         String   @id
  topic      String
  eventType  String
  event      String
  createdAt  DateTime
  retryCount Int      @default(0)
  retryAfter DateTime

  @@index([createdAt])
}

enum FriendShipStatus {
  PENDING
  ACCEPTED
}
